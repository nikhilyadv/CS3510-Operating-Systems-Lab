[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 13] = SP;
alias userSP R0;
userSP=SP;
SP = [PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 11]*512 - 1;
alias PhysicalPageNum R1;							//Extracting arguement 
alias offset R2;
alias CallNumAdd R3;
PhysicalPageNum = [PTBR + 2 * ((userSP - 5)/ 512)];
offset = (userSP - 5) % 512;
CallNumAdd = (PhysicalPageNum * 512) + offset;
alias SyscallNumber R4;
SyscallNumber = [CallNumAdd];
//Both calls search inode table so it better to combine
alias filename R5;
PhysicalPageNum = [PTBR + 2 * ((userSP - 4)/ 512)];
offset = (userSP - 4) % 512;
CallNumAdd = (PhysicalPageNum * 512) + offset;
filename = [CallNumAdd];
alias fileindex R7;
alias flag R8;
alias freeentry R9;
flag = 0;
fileindex = 0;				//inode table page 59
freeentry = -1;
while (fileindex < 60) do
	if ([INODE_TABLE + fileindex * 16 + 1] == -1 && freeentry == -1) then
		freeentry = fileindex;
	endif;
	if ([INODE_TABLE + fileindex * 16 + 1] == filename) then
		flag = 1;
		break;
	endif;
	fileindex = fileindex + 1;
endwhile;
//return address
alias physicalAddrRetVal R10;
physicalAddrRetVal = ([PTBR + 2 * ((userSP - 1) / 512)] * 512) + ((userSP - 1) % 512);
if (SyscallNumber == 1) then			//Create
	[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 9] = 1;
	alias permission R6;
	PhysicalPageNum = [PTBR + 2 * ((userSP - 3)/ 512)];
	offset = (userSP - 3) % 512;
	CallNumAdd = (PhysicalPageNum * 512) + offset;
	permission = [CallNumAdd];
	if (flag == 1) then
		[physicalAddrRetVal] = -1;					//file present in disk
	else
		[INODE_TABLE + freeentry * 16 + 0] = DATA;
		[INODE_TABLE + freeentry * 16 + 1] = filename;
		[INODE_TABLE + freeentry * 16 + 2] = 0;
		[INODE_TABLE + freeentry * 16 + 3] = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 3];
		[INODE_TABLE + freeentry * 16 + 4] = permission;	
		[INODE_TABLE + freeentry * 16 + 8] = -1;
		[INODE_TABLE + freeentry * 16 + 9] = -1;
		[INODE_TABLE + freeentry * 16 + 10] = -1;
		[INODE_TABLE + freeentry * 16 + 11] = -1;
		[ROOT_FILE + freeentry * 8 + 0] = filename;
		[ROOT_FILE + freeentry * 8 + 1] = 0;
		[ROOT_FILE + freeentry * 8 + 2] = DATA;
		[ROOT_FILE + freeentry * 8 + 3] = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 3];
		[ROOT_FILE + freeentry * 8 + 4] = permission;
		[physicalAddrRetVal] = 0;				//Return value	
	endif;
endif;
if (SyscallNumber == 4) then				//delete
	[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 9] = 4;
	alias temp R11;
	temp = 0;
	if (flag == 0) then
		[physicalAddrRetVal] = 0;
	else
		if ([INODE_TABLE + fileindex * 16 + 0] != DATA) then
				[physicalAddrRetVal] = 0;
		else
			if ([INODE_TABLE + freeentry * 16 + 4] == 0) then
				if ([PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 3] != ROOT && [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 3] != [INODE_TABLE + freeentry * 16 + 3]) then					//root abstract here correct it later
					[physicalAddrRetVal] = -1;
					temp = -1;
				endif;
			endif;
			if (temp != -1) then
				multipush(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11);
				R1 = 4;											//acquire inode
				R2 = fileindex;
				R3 = [SYSTEM_STATUS_TABLE + 1];
				call MOD_0;
				multipop(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11);
				if(R0 != -1) then								//lock accquired
					if ([FILE_STATUS_TABLE + fileindex * 4 + 1] != -1) then
						[physicalAddrRetVal] = -2;
						multipush(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11);		//release
						R1 = 5;											//release inode
						R2 = fileindex;
						R3 = [SYSTEM_STATUS_TABLE + 1];						
						call MOD_0;
						multipop(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11);
					else
						alias counter R12;
						alias iter R13;
						counter = 8;
						while (counter < 12) do
							if ([INODE_TABLE + freeentry * 16 + counter] != -1) then
								iter = 0;
								while (iter < 4) do
									if ([BUFFER_TABLE + iter * 4 + 0] == [INODE_TABLE + freeentry * 16 + counter] && [BUFFER_TABLE + iter * 4 + 1] == 1) then
										[BUFFER_TABLE + iter * 4 + 1] = 0;
									endif;
									iter = iter + 1;
								endwhile;
								multipush(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13);	
								R1 = 4;											//release block
								R2 = [INODE_TABLE + freeentry * 16 + counter];
								R3 = [SYSTEM_STATUS_TABLE + 1];						
								call MOD_2;
								multipop(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13);
							endif;
							counter = counter + 1;
							[INODE_TABLE + freeentry * 16 + counter] = -1;
						endwhile;
						[ROOT_FILE + freeentry * 8 + 0] = -1;			//invalidate root entry
						//multipush(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13);		//release
						R1 = 5;											//release inode
						R2 = fileindex;
						R3 = [SYSTEM_STATUS_TABLE + 1];						
						call MOD_0;
						//multipop(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13);
						[physicalAddrRetVal] = 0;
					endif;
				endif;
			endif;
		endif;
	endif;
endif;
SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 13];
[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 9] = 0;
ireturn;